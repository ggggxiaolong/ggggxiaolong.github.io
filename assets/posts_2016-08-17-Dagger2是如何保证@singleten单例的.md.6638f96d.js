import{_ as e,o as a,c as t,U as o}from"./chunks/framework.70292381.js";const _=JSON.parse('{"title":"Dagger2 是如何保证单例的","description":"","frontmatter":{"title":"Dagger2 是如何保证单例的","date":"2016-08-17T12:00:00.000Z","categories":["Android"],"tags":["Dagger2"]},"headers":[],"relativePath":"posts/2016-08-17-Dagger2是如何保证@singleten单例的.md","filePath":"posts/2016-08-17-Dagger2是如何保证@singleten单例的.md"}'),i={name:"posts/2016-08-17-Dagger2是如何保证@singleten单例的.md"},r=o('<h3 id="提出问题" tabindex="-1">提出问题 <a class="header-anchor" href="#提出问题" aria-label="Permalink to &quot;提出问题&quot;">​</a></h3><ul><li>dagger2是如何保证@singleten单例的？</li></ul><h3 id="准备知识" tabindex="-1">准备知识 <a class="header-anchor" href="#准备知识" aria-label="Permalink to &quot;准备知识&quot;">​</a></h3><p>如果你还没有了解过dagger2，不知道component，scope，model，provider，inject。建议你先对dagger2有一个大概的了解。有一些文章我觉得很棒（都提供了具体的项目在github），你可以阅读，并实践一下：</p><ul><li><a href="http://www.jianshu.com/p/cd2c1c9f68d4" target="_blank" rel="noreferrer">Android：dagger2让你爱不释手-基础依赖注入框架篇</a></li><li><a href="http://www.jianshu.com/p/1d42d2e6f4a5" target="_blank" rel="noreferrer">Android：dagger2让你爱不释手-重点概念讲解、融合篇</a></li><li><a href="http://www.jianshu.com/p/65737ac39c44" target="_blank" rel="noreferrer">Android：dagger2让你爱不释手-终结篇</a></li><li><a href="https://github.com/luxiaoming/dagger2Demo" target="_blank" rel="noreferrer">Dagger2图文完全教程</a></li></ul><h3 id="解决问题" tabindex="-1">解决问题 <a class="header-anchor" href="#解决问题" aria-label="Permalink to &quot;解决问题&quot;">​</a></h3><p>基于<a href="https://github.com/luxiaoming/dagger2Demo" target="_blank" rel="noreferrer">这个项目讲解</a></p><h5 id="有那些地方使用了-singleten注解-代表类的方法" tabindex="-1">有那些地方使用了@Singleten注解（#代表类的方法） <a class="header-anchor" href="#有那些地方使用了-singleten注解-代表类的方法" aria-label="Permalink to &quot;有那些地方使用了@Singleten注解（#代表类的方法）&quot;">​</a></h5><ul><li>ApplicationComponent</li><li>AndroidModule#ApplicationContext()</li><li>AndroidModule#provideLocationManager()</li></ul><h5 id="他们之间的关系" tabindex="-1">他们之间的关系 <a class="header-anchor" href="#他们之间的关系" aria-label="Permalink to &quot;他们之间的关系&quot;">​</a></h5><p><img src="https://res.cloudinary.com/xiaolong/image/upload/v1612398731/blog/1419533-717e696a4ded2cc3.png_usqqu1.png" alt="Dagger2Demo_@Singleton.png"></p><ul><li>我们知道Application相当于单例。application中的全局变量的生命周期和application是一致的，例如ApplicationComponent，它的实现类为DaggerApplicationModule（由Dagger2生成，实现了ApplicationComponent接口）。</li><li>那些有@Singleton注解（AndroidModule和Inject）的在DaggerApplicationComponent中由DoubleCheck管理，没有任何注解的由Factory管理</li><li><strong>DoubleCheck和Factory的区别是DoubleCheck会将第一次生成的目标对象缓存下来，以后的调用将直接返回缓存的对象。而Factory每次获取目标对象都是重新生成（调用module中的方法）。</strong></li><li>Application中保存了DaggerApplicationComponent对象，DaggerApplicationComponent保存了DoubleCheck对象，DoubleCheck对象保存了目标对象（Context或LocationManager）。从而保证了Context和LocationManager在整个App中的单例。</li></ul><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>由此可以得出：促使目标对象成为单例的并不是@Singleton注解，而是Application。（它的目的只是为了方便记忆）</p>',14),n=[r];function l(g,c,p,d,s,h){return a(),t("div",null,n)}const m=e(i,[["render",l]]);export{_ as __pageData,m as default};
