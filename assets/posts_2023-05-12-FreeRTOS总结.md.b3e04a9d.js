import{_ as t,o as e,c as d,U as o}from"./chunks/framework.70292381.js";const a="/assets/2023-05-12_15-04.df176c07.png",k=JSON.parse('{"title":"FreeRTOS 总结","description":"","frontmatter":{"title":"FreeRTOS 总结","date":"2023-05-12T00:00:00.000Z","categories":["FreeRTOS"],"tags":["FreeRTOS"]},"headers":[],"relativePath":"posts/2023-05-12-FreeRTOS总结.md","filePath":"posts/2023-05-12-FreeRTOS总结.md"}'),r={name:"posts/2023-05-12-FreeRTOS总结.md"},i=o(`<h1 id="freertos-总结" tabindex="-1">FreeRTOS 总结 <a class="header-anchor" href="#freertos-总结" aria-label="Permalink to &quot;FreeRTOS 总结&quot;">​</a></h1><h3 id="task" tabindex="-1">Task <a class="header-anchor" href="#task" aria-label="Permalink to &quot;Task&quot;">​</a></h3><ol><li><p>头文件 <code>task.h</code></p></li><li><p>创建 <code>xTaskCreate</code></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>TaskFunction_t pvTaskCode</td><td>任务函数名</td></tr><tr><td>const char * const pcName</td><td>描述</td></tr><tr><td>unsigned short usStackDepth</td><td>任务使用的栈深度</td></tr><tr><td>void *pvParameters</td><td>传入任务的参数指针</td></tr><tr><td>UBaseType_t uxPriority</td><td>优先级</td></tr><tr><td>TaskHandle_t *pxCreatedTask</td><td>任务句柄的指针</td></tr></tbody></table><p>任务函数： 死循环，或者执行结束删除自己<code>vTaskDelete</code></p><p>描述： 后续可以通过<code>pcTaskGetName</code> 方法获取函数的描述</p><p>任务参数：需要将参数的指针强制转换成 <code>void *</code> 类型， 在任务内部在转回对应的类型</p><p>栈深度： 这个任务能使用的最大<strong>字</strong>，<strong>字</strong>与 MCU 相关， 可以通过 <code>uxTaskGetStackHighWaterMark</code> 获取运行时最小任务的栈剩余空间</p><p>优先级：数字越高，优先级越高， 后续可以通过<code> vTaskPrioritySet</code> 设置， 通过 <code>uxTaskPriorityGet</code> 获取</p><p>任务句柄：注意这是二级指针，不需要时传 <code>NULL</code></p></li><li><p>获取任务列表信息 <code>vTaskList</code> ，内容分别为 描述/状态/优先级/栈空间/唯一值</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Name            State   Priority    Stack    Num</span></span>
<span class="line"><span style="color:#A6ACCD;">task_suspend_1  R       1       848     4</span></span>
<span class="line"><span style="color:#A6ACCD;">task_suspend_4  R       1       860     5</span></span>
<span class="line"><span style="color:#A6ACCD;">main            X       1       3480    2</span></span>
<span class="line"><span style="color:#A6ACCD;">IDLE            R       0       1372    3</span></span>
<span class="line"><span style="color:#A6ACCD;">esp_timer       S       22      3876    1</span></span></code></pre></div><p>任务状态 <code>X</code> -- 运行， <code>B</code> -- 阻塞， <code>R</code> -- 就绪， <code>S</code> -- 阻塞， <code>D</code> -- 已删除(未被移除)</p><p><img src="`+a+'" alt="1"></p></li><li><p>任务的通知</p><p>每个任务都有一个32位的通知值，初始值为0；<code>xTaskNotifyWait</code> 等待通知值的改变，<code>xTaskNotify</code> 设置通知的值， <code>xTaskNotifyGive</code>唤醒任务(通知值加1)， <code>ulTaskNotifyTake</code> 等待唤醒并获取通知值。</p><ol><li><p>xTaskNotifyWait</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>uint32_t ulBitsToClearOnEntry</td><td>进入时清空的位</td></tr><tr><td>uint32_t ulBitsToClearOnExit</td><td>退出时清空的位</td></tr><tr><td>uint32_t *pulNotificationValue</td><td>赋值通知值的指针</td></tr><tr><td>TickType_t xTicksToWait</td><td>最大Tick等待</td></tr></tbody></table></li><li><p>xTaskNotify</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>TaskHandle_t xTaskToNotify</td><td>任务句柄</td></tr><tr><td>uint32_t ulValue</td><td>更新通知的值</td></tr><tr><td>eNotifyAction eAction</td><td>更新方式<br> * eNoAction 唤醒任务但不修改通知值<br> * eSetBits 通知值与ulValue按位或<br> * eIncrement 通知的值自增<br> * eSetValueWithOverwrite 用ulValue覆盖通知值<br> * eSetValueWithoutOverwrite 如果通知已经有值待唤醒则返回失败，否则设置为ulValue</td></tr></tbody></table></li><li><p>xTaskNotifyGive 使通知值自增</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>TaskHandle_t xTaskToNotify</td><td>函数句柄</td></tr></tbody></table></li><li><p>ulTaskNotifyTake 当通知的值非0是唤醒</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>BaseType_t xClearCountOnExit</td><td>pdFALSE 退出时通知值自减<br>pdTRUE 退出时通知值设置为 0</td></tr><tr><td>TickType_t xTicksToWait</td><td>最大Tick等待</td></tr></tbody></table></li></ol></li><li><p>任务的阻塞和恢复 <code>vTaskSuspend</code> 阻塞任务， <code>vTaskResume</code> 恢复任务，<code>xTaskResumeAll</code> 恢复所有任务， <code>vTaskSuspendAll</code> 阻塞所有任务，阻塞之后不能使用FreeRTOS的函数</p></li><li><p>看门狗任务 <code>IDLE</code> 优先级为0, 如果其他任务一直执行， 5s 内<code>IDLE</code> 的不到执行会触发看门狗。<code>vTaskDelay</code> 可以让出时间片</p></li></ol><h3 id="队列" tabindex="-1">队列 <a class="header-anchor" href="#队列" aria-label="Permalink to &quot;队列&quot;">​</a></h3><ol><li>头文件<code>queue.h</code></li><li>创建 <code>xQueueCreate</code>， 参数为队列的长度和宽度</li><li>发送数据 <code>xQueueSend</code>， 接收数据 <code>xQueueReceive</code>， 查询队列中项目的数量<code>uxQueueMessagesWaiting</code></li><li>邮箱：创建队列的长度为1， 写入数据使用 <code>xQueueOverwrite</code>， 读取使用 <code>xQueuePeek</code></li><li>多发送者单接收者， 需要将接收者的优先级调高</li><li>队列集合：创建集合 <code>xQueueCreateSet</code>， 将队列加入集合 <code>xQueueAddToSet</code>, 从集合中挑选有数据的队列 <code>xQueueSelectFromSet</code></li></ol><h3 id="信号量" tabindex="-1">信号量 <a class="header-anchor" href="#信号量" aria-label="Permalink to &quot;信号量&quot;">​</a></h3><ol><li>头文件<code>semphr.h</code></li><li>让出信号量 <code>xSemaphoreGive</code>， 获取信号量 <code>xSemaphoreTake</code></li><li>二进制信号量 <code>xSemaphoreCreateBinary</code>， 用于两个相同优先级的任务交替运行</li><li>互斥信号量<code>xSemaphoreCreateMutex</code>， 类似于二进制信号量，但是如果<strong>任务1</strong>已经获取信号量，其他高优先级的<strong>任务2</strong>获取信号量时，<strong>任务1</strong>会临时提高到<strong>任务二</strong>的优先级。</li><li>计数信号量 <code>xSemaphoreCreateCounting</code> 让出信号量会增加计数，获取信号量会减少计数，计数等于0时会阻塞获取信号量的任务。</li><li>递归信号量 <code>xSemaphoreCreateRecursiveMutex</code> 用于锁定多个资源 获取信号量<code>xSemaphoreTakeRecursive</code> 让出信号量<code>xSemaphoreGiveRecursive</code></li></ol><h3 id="软件定时器" tabindex="-1">软件定时器 <a class="header-anchor" href="#软件定时器" aria-label="Permalink to &quot;软件定时器&quot;">​</a></h3><ol><li><p>头文件<code>timers.h</code></p></li><li><p>创建定时器 <code>xTimerCreate</code></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>const char *pcTimerName</td><td>描述</td></tr><tr><td>const TickType_t xTimerPeriod</td><td>Tick 周期</td></tr><tr><td>const UBaseType_t uxAutoReload</td><td>pdFALSE 只执行一次<br>pdTRUE 周期执行</td></tr><tr><td>void * const pvTimerID</td><td>标识唯一</td></tr><tr><td>TimerCallbackFunction_t pxCallbackFunction</td><td>执行的函数名</td></tr></tbody></table></li><li><p>执行定时器<code>xTimerStart</code> ，结束定时器 <code>xTimerStop</code>， 删除定时器<code>xTimerDelete</code>，重置定时器计时 <code>xTimerReset</code> （如果在定时器执行前重置则执行函数将等不到执行类似看门狗），改变定时器的执行周期 <code>xTimerChangePeriod</code></p></li></ol><h3 id="事件组" tabindex="-1">事件组 <a class="header-anchor" href="#事件组" aria-label="Permalink to &quot;事件组&quot;">​</a></h3><ol><li><p>头文件 <code>event_groups.h</code></p></li><li><p>事件组存储在一个8/24位的变量中通过设置对应的位和检查对应的位控制任务的执行</p></li><li><p>等待事件组：一个任务等待其他任务(全部或任意任务设置)，设置位 <code>xEventGroupSetBits</code> ， 等待位设置 <code>xEventGroupWaitBits</code></p><table><thead><tr><th>xEventGroupWaitBits参数</th><th>含义</th></tr></thead><tbody><tr><td>const EventGroupHandle_t xEventGroup</td><td>事件组</td></tr><tr><td>const EventBits_t uxBitsToWaitFor</td><td>等待的位(如果等待多个位, 使用<strong>位或</strong>连接)</td></tr><tr><td>const BaseType_t xClearOnExit</td><td>pdTRUE 函数退出前清空等待的位<br>pdFALSE 不修改</td></tr><tr><td>const BaseType_t xWaitForAllBits</td><td>pdTRUE 等待所有位都被设置<br>pdFALSE 任意位被设置都会唤醒</td></tr><tr><td>TickType_t xTicksToWait</td><td>等待Tick周期</td></tr></tbody></table></li><li><p>同步事件组：所有任务设置自己的位并等待其他任务设置 <code>xEventGroupSync</code></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>EventGroupHandle_t xEventGroup</td><td>事件组</td></tr><tr><td>const EventBits_t uxBitsToSet</td><td>设置的位</td></tr><tr><td>const EventBits_t uxBitsToWaitFor</td><td>等待的位(如果等待多个位, 使用<strong>位或</strong>连接)</td></tr><tr><td>TickType_t xTicksToWait</td><td>等待Tick周期</td></tr></tbody></table></li></ol><h3 id="流缓冲区" tabindex="-1">流缓冲区 <a class="header-anchor" href="#流缓冲区" aria-label="Permalink to &quot;流缓冲区&quot;">​</a></h3><ol><li><p>头文件 <code>stream_buffer.h</code></p></li><li><p>将数据写入缓冲区或从缓冲区读取数据， 只要缓冲区的数据大于唤醒任务需要的大小就会唤起任务读取数据，如果读取数据buffer小于缓存区的数据会分包获取数据。</p></li><li><p>创建 <code>xStreamBufferCreate</code></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>size_t xBufferSizeBytes</td><td>缓冲区的大小</td></tr><tr><td>size_t xTriggerLevelBytes</td><td>触发读操作的字节数</td></tr></tbody></table></li><li><p>发送数据 <code>xStreamBufferSend</code>， 读取数据 <code>xStreamBufferReceive</code>， 检查 <code>xStreamBufferSpacesAvailable</code> 缓冲区的剩余空间可以通过这个方法调整创建缓冲区的大小， <code>xStreamBufferIsFull</code> 缓冲区是否已经满， <code>xStreamBufferIsEmpty</code> 缓冲区是否为空</p></li></ol><h3 id="消息缓冲区" tabindex="-1">消息缓冲区 <a class="header-anchor" href="#消息缓冲区" aria-label="Permalink to &quot;消息缓冲区&quot;">​</a></h3><ol><li>头文件 <code>message_buffer.h</code></li><li>类似于 <strong>流缓冲区</strong> 不同点 <ol><li>创建时不需要设置触发字节数</li><li>一次接受一个消息</li><li>如果接受的buffer小于缓存区的一条消息的大小则读取失败</li></ol></li></ol>',15),c=[i];function l(s,n,p,h,u,T){return e(),d("div",null,c)}const b=t(r,[["render",l]]);export{k as __pageData,b as default};
